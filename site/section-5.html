<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent SDK to Agent Server — Agent SDKs for the Rest of Us</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body class="content-page">

    <aside class="sidebar">
        <div class="sidebar-header">
            <span class="mono-label sidebar-header__label">Report</span>
            <h1 class="sidebar-header__title"><a href="index.html">Agent SDKs for the Rest of Us</a></h1>
        </div>
        <nav class="sidebar-nav">
            <a href="section-1.html" class="nav-item">
                <span class="nav-num">01</span>
                <span class="nav-title">Mapping the Terrain</span>
            </a>
            <a href="section-2.html" class="nav-item">
                <span class="nav-num">02</span>
                <span class="nav-title">What's an Agent, Anyway?</span>
            </a>
            <a href="section-3.html" class="nav-item">
                <span class="nav-num">03</span>
                <span class="nav-title">Where Orchestration Lives</span>
            </a>
            <a href="section-4.html" class="nav-item">
                <span class="nav-num">04</span>
                <span class="nav-title">Two Tools to Rule Them All</span>
            </a>
            <a href="section-5.html" class="nav-item active">
                <span class="nav-num">05</span>
                <span class="nav-title">Agent SDK to Agent Server</span>
            </a>
            <a href="section-6.html" class="nav-item">
                <span class="nav-num">06</span>
                <span class="nav-title">Architecture by Example</span>
            </a>
            <a href="section-7.html" class="nav-item">
                <span class="nav-num">07</span>
                <span class="nav-title">Further Reading</span>
            </a>
        </nav>
    </aside>

    <main class="content-main">
        <div class="top-bar">
            <div class="top-bar__meta">
                <div class="meta-item">
                    <span class="mono-label">Subject</span>
                    <span class="meta-item__value">Agent Frameworks</span>
                </div>
                <div class="meta-item">
                    <span class="mono-label">Date</span>
                    <span class="meta-item__value">Feb 2026</span>
                </div>
            </div>
            <div class="meta-item">
                <span class="mono-label">Section</span>
                <span class="meta-item__value">05 / 07</span>
            </div>
        </div>

        <div class="content-body">
            <div class="content-body__section-num">05</div>
            <h1 class="content-body__title">Agent SDK to Agent Server</h1>

<p>Agent SDKs are libraries. They run on your machine, inside your application. When your application stops, the agent stops.</p>
<p>This works well for many use cases. But if you want to build something like ChatGPT — where the agent runs on a server, keeps working after you close the tab, and is accessible from anywhere — you need an agent server.</p>
<p>Part 4 explains the difference between the two, and what you need to build to get from one to the other.</p>
<h2>What&#39;s an Agent &quot;SDK&quot; anyway?</h2>
<h3>Libraries and services</h3>
<p><strong>Think of the difference between Excel and Google Sheets.</strong></p>
<p>An Excel spreadsheet lives on your machine. Nobody else can see it while you&#39;re working. It exists on your machine and only your machine.</p>
<p>Google Sheets lives on Google&#39;s servers. You open it in a browser, but the spreadsheet is not on your machine. You can close your browser and it&#39;s still there. You can open it from your phone, from another laptop, share it with colleagues who edit it at the same time. Google Sheets keeps running whether or not you&#39;re connected.</p>
<p>Same capability (a spreadsheet), two ways to package it:</p>
<ol>
<li><p><strong>Embedded</strong> — runs on your machine. Excel, a calculator app, a file on your disk. When your machine is off, it&#39;s off.</p>
</li>
<li><p><strong>Hosted</strong> — runs on someone else&#39;s machine. Google Sheets, ChatGPT, your email. You connect to it over the network. It keeps going after you disconnect.</p>
</li>
</ol>
<p>The boundary between your machine and the remote one is the <strong>service boundary</strong>.</p>
<p>More precisely, the distinction is not about physical machines — it is about whether a capability runs inside your application or as a separate, independent process. Your application calls a library directly; it connects to a service over a protocol.</p>
<p><strong>A more technical example: databases.</strong></p>
<p>SQLite is embedded. Your application links the library, calls functions directly. No service boundary. When your app exits, SQLite exits.</p>
<p>PostgreSQL is hosted. It runs as a separate server process. Your application connects over a socket, sends SQL as messages, receives results. Service boundary. PostgreSQL keeps running after your app disconnects.</p>
<p>Same domain (relational database), two packaging modes.</p>
<!-- TODO: illustration — two diagrams side by side. Left: "Embedded" showing your machine with the app inside it. Right: "Hosted" showing your machine connecting over the network to a server with the app inside it. The network connection is the service boundary. -->

<h3>What is the difference between an Agent SDK and a &quot;regular agent&quot;</h3>
<p>An Agent SDK provides the same kind of capabilities you would expect from a coding agent — but as functions you call from your own code:</p>
<ul>
<li><strong>Send a prompt, get a response</strong> — the equivalent of typing a message in Claude Code. In the SDK: <code>query(prompt)</code>.</li>
<li><strong>Resume a previous conversation</strong> — pick up where you left off, with full context. In the SDK: pass a <code>sessionId</code>.</li>
<li><strong>Control which tools the agent can use</strong> — restrict it to read-only, or give it full access. In the SDK: <code>allowedTools</code>.</li>
<li><strong>Intercept the agent&#39;s behavior</strong> — get notified before or after a tool call, log actions, add approval gates. In the SDK: hooks.</li>
</ul>
<pre><code class="language-python"># Send a prompt to the Claude Agent SDK with a list of allowed tools
from claude_agent_sdk import query

async for message in query(
    prompt=&quot;Run the test suite and fix any failures&quot;,
    options={&quot;allowed_tools&quot;: [&quot;Bash&quot;, &quot;Read&quot;, &quot;Edit&quot;]}
):
    print(message)
</code></pre>
<p>The difference between an &quot;Agent SDK&quot; and a &quot;regular agent&quot; such as Claude Code is that it provides a &quot;programmable interface&quot; (API) instead of a user interface. </p>
<p>With an Agent SDK, you may:</p>
<ul>
<li><strong>Automate</strong> tasks that an agent is better suited to manage. Trigger the agent, let it run to completion — no human in the loop. Hook into the agent&#39;s behavior to log actions, enforce constraints, or get structured results instead of terminal text.</li>
<li><strong>Extend</strong> an existing app with an agentic feature — embed agent capabilities inside an application where a user interacts with the agent through your own interface, not the agent&#39;s CLI.</li>
</ul>
<p><strong>Example: automated code review in CI.</strong></p>
<ul>
<li>You run the Claude Agent SDK in a GitHub Actions job. </li>
<li>When a PR is opened, the agent reviews the code, runs tests, and posts comments. </li>
<li>There is no service boundary: the agent is instantiated within the GitHub Actions runner process, and is constrained by that runner&#39;s limits — 6-hour max job duration, fixed RAM and disk, no persistent state between runs.</li>
</ul>
<p><strong>Example: agentic search in a support app.</strong></p>
<ul>
<li>A customer support app has a search bar. </li>
<li>When a support agent types a question, the app calls <code>query()</code> and the agent searches the knowledge base, ticket history,... The agent synthesizes an answer from multiple sources and returns it to the app, which displays it in the UI.</li>
<li>The agent is a function call within the app process. When the search completes (or the user navigates away), the session is gone. No agent service boundary.</li>
</ul>
<p><strong>In both cases, the agent runs within the host process.</strong> It starts, does its work, and stops. No independent lifecycle. No reconnection. No background continuation.</p>
<h2>How is an Agent Server different from an Agent SDK?</h2>
<h3>The Agent Server use case</h3>
<p>If you want to build a ChatGPT clone, an Agent SDK is a start. But it&#39;s not enough.</p>
<p><strong>An Agent Server is required when the agent must outlive the client:</strong></p>
<ul>
<li>Access from anywhere, not just a CI job or a bot on your server.</li>
<li>Close your browser, come back later, and find the agent still running — or finished.</li>
<li>Multiple people connecting to the same agent session.</li>
<li>Real-time progress as the agent works.</li>
</ul>
<p><strong>This is when the agent&#39;s lifecycle must be decoupled from the client&#39;s</strong>: </p>
<ul>
<li>The agent runs in a separate process. </li>
<li>You connect to it over the network. </li>
<li>You disconnect, and it keeps going.</li>
</ul>
<p><strong>You cannot just put the SDK on a server and call it done.</strong> The SDK gives you the agent loop. It does not handle what comes with running a process that other people connect to over a network:</p>
<ul>
<li><strong>Authentication</strong> — who is allowed to talk to this agent, and how do you verify that?</li>
<li><strong>Network resilience</strong> — clients disconnect, requests timeout, connections drop mid-stream. The library assumes a stable in-process caller.</li>
</ul>
<h3>Agent-specific server capabilities</h3>
<p>Authentication and network resilience need to be thought through for any client-server application. Agents require additional layers:</p>
<p><strong>Transport</strong> — how the user&#39;s browser (or app) talks to the agent server. You build an HTTP server that accepts requests and returns agent output. The question is how much real-time interaction you need:</p>
<ul>
<li><strong>HTTP request/response</strong> — the user submits a task and waits for the complete result. No progress updates while the agent works. </li>
<li><strong>HTTP + SSE (Server-Sent Events)</strong> — the server streams the agent&#39;s output to the user as it happens, but the stream is one-way: server to client. The user watches the agent think and act in real time (like ChatGPT responses appearing token by token) but cannot send anything back until the stream ends.</li>
<li><strong>WebSocket</strong> — a persistent two-way connection. The user can send messages while the agent is working — approve a command, provide clarification, or cancel a task — without waiting for the current stream to finish. WebSocket is also required for multiple people to connect to the same session.</li>
</ul>
<p><strong>Routing</strong> — how each message reaches the right conversation. </p>
<ul>
<li>Think of the ChatGPT sidebar: you have multiple conversations, you can switch between them, and each new message goes to the one you&#39;re looking at. </li>
<li>You build this by assigning a session ID to each conversation and maintaining a registry — a lookup table that maps session IDs to agent processes. </li>
<li>When a message comes in, the server looks up the session ID and forwards the message to the right place.</li>
</ul>
<p><strong>Persistence</strong> — how conversations can be accessed and resumed later.</p>
<ul>
<li>The user closes the tab, reopens it the next day. They expect to find their conversation history, the artifacts the agent created, and have the ability to continue where they left off. </li>
<li>You build this by &quot;persisting&quot; the conversation state (messages, context, artifacts). Unless the runtime is run without interruption that means saving the state and reloading it when the user reconnects. </li>
<li>Part 5 shows how different projects solve this differently.</li>
</ul>
<p><strong>Lifecycle</strong> — what happens when the user closes the tab while the agent is working.</p>
<ul>
<li>Without lifecycle management, you already have a working agent server — it handles requests, streams responses, routes to the right session, and persists state. But the agent runs inside the request handler. When the user disconnects, the connection closes and the agent stops. For longer tasks, you need the agent to survive disconnection. </li>
<li>To do so, first you need to separate the agent process from the request handler. The agent runs in its own container or background process, not inside the HTTP handler. </li>
<li>Then you need to add a supervisor that monitors running agents — tracks which ones are active, detects when they finish or fail, and cleans up resources.</li>
<li>Finally you may add a notification mechanism — when the agent finishes, the user needs to know. A Slack message, an email, a push notification, or a status the user can poll.</li>
</ul>
<!-- TODO: illustration — concentric circles (onion diagram). Inner circle: "Agent loop (Claude Agent SDK, py-sdk)". Next ring: "Session management". Next ring: "Transport (HTTP/WS)". Next ring: "Routing". Outer ring: "Persistence, lifecycle". Label the whole thing: "What you build with SDK-first". Then show OpenCode as a pre-assembled version with all layers included. -->

<h2>OpenCode: the only Agent Server</h2>
<p>OpenCode ships as a server with most layers built in. But &quot;built in&quot; does not mean &quot;production-ready for every use case.&quot;</p>
<p>In particular OpenCode is an agent server for a single machine. To turn it into a distributed, internet-facing service, you need to build the missing pieces yourself — or use a platform that provides them (see the Ramp example in Part 5)</p>
<table>
<thead>
<tr>
<th>Layer</th>
<th>OpenCode provides</th>
<th>What it does not provide</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Transport</strong></td>
<td>HTTP API + SSE streaming. Client sends prompts via POST, receives output via SSE.</td>
<td>No WebSocket. SSE is one-way — the client cannot send messages while the agent is streaming without making a separate HTTP request.</td>
</tr>
<tr>
<td><strong>Routing</strong></td>
<td>Full session management — create, list, fork, delete conversations. Each session has an ID.</td>
<td>Sessions are scoped to one machine. No global registry for routing across multiple servers or sandboxes.</td>
</tr>
<tr>
<td><strong>Persistence</strong></td>
<td>Sessions, messages, and artifacts saved to disk as JSON files. Restart the server and conversations are still there.</td>
<td>Persistence is tied to the local filesystem. If the machine or sandbox is destroyed, the files are gone. No external database, no durable state across environments.</td>
</tr>
<tr>
<td><strong>Lifecycle</strong></td>
<td>Server continues running when client disconnects. Agent keeps processing. Reconnect with <code>opencode attach</code>.</td>
<td>No recovery from server crashes — in-flight work is lost. No job queue, no supervisor, no automatic restart.</td>
</tr>
<tr>
<td><strong>Multi-client</strong></td>
<td>Multiple SSE clients can watch the same session simultaneously.</td>
<td>Only one client can prompt at a time (busy lock). No presence awareness, no real-time sync between clients. Multiple viewers, single driver.</td>
</tr>
<tr>
<td><strong>Authentication</strong></td>
<td>Optional HTTP Basic Auth.</td>
<td>No tokens, no user identity, no multi-tenant isolation, no fine-grained permissions.</td>
</tr>
</tbody></table>
<h2>What to keep in mind</h2>
<ul>
<li><strong>Library vs service is the fundamental question.</strong> The same capability — the agent loop — can run embedded (in your process) or hosted (behind a service boundary). The choice depends on whether you need independent lifecycle, multiple clients, or remote access.</li>
<li><strong>Start with the SDK.</strong> Most use cases — CI automation, embedded search, internal tools — work fine with the agent running inside your process. You only need a server when the agent must outlive the client.</li>
<li><strong>The server layers are cumulative.</strong> Transport, routing, persistence, lifecycle — each adds complexity. You don&#39;t need all of them. A job agent needs transport and nothing else. Background continuation needs all four.</li>
</ul>

        </div>
    </main>

</body>
</html>
